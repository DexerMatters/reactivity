use std::{
    cell::{Ref, RefCell, RefMut},
    ops::{Deref, DerefMut},
    rc::Rc,
    sync::Arc,
};

/// A trait for creating a new instance of a type with a given value.
pub trait Constructor<T> {
    /// Creates a new instance of the type with the given value.
    fn init(value: T) -> Self;
}

impl<T> Constructor<T> for Rc<T> {
    fn init(value: T) -> Self {
        Rc::new(value)
    }
}

impl<T> Constructor<T> for Arc<T> {
    fn init(value: T) -> Self {
        Arc::new(value)
    }
}

/// A trait for shared pointer types that provide interior mutability.
///
/// Implemented for `Rc<RefCell<T>>` and `Arc<parking_lot::RwLock<T>>`.
pub trait Shared<T>: Clone {
    /// The inner type of the shared pointer.
    type Inner;

    /// The pointer type used for shared ownership.
    type Ptr<U>: Shared<U>;

    /// The type of the sharable reference countable pointer.
    type Rc<U>: Constructor<U> + Deref + AsRef<U> + Clone;

    /// The type of the reference to the inner value.
    type Ref<'a, U>: Deref<Target = U>
    where
        Self: 'a,
        U: 'a;

    /// The type of the mutable reference to the inner value.
    type RefMut<'a, U>: Deref<Target = U> + DerefMut<Target = U>
    where
        Self: 'a,
        U: 'a;

    /// Creates a new instance of the shared pointer with the given value.
    fn new(value: T) -> Self;

    /// Borrows the inner value as an immutable reference.
    fn borrow(&self) -> Self::Ref<'_, T>;

    /// Borrows the inner value as a mutable reference.
    fn borrow_mut(&self) -> Self::RefMut<'_, T>;

    fn get_ref(&self) -> &T;

    /// Replaces the inner value with a new value and returns the old value.
    fn replace(&self, value: T) -> Self {
        self.replace_with(|_| value)
    }

    /// Replaces the inner value with a new value generated by the given function
    fn replace_with<F>(&self, f: F) -> Self
    where
        F: FnOnce(&T) -> T,
    {
        let mut borrow = self.borrow_mut();
        let new_value = f(&*borrow);
        *borrow = new_value;
        drop(borrow);
        self.clone()
    }
}

impl<T> Shared<T> for Rc<RefCell<T>> {
    type Inner = T;
    type Ptr<U> = Rc<RefCell<U>>;
    type Rc<U> = Rc<U>;
    type Ref<'a, U> = Ref<'a, U> where Self: 'a, U: 'a;
    type RefMut<'a, U> = RefMut<'a, U> where Self: 'a, U: 'a;

    fn new(value: T) -> Self {
        Rc::new(RefCell::new(value))
    }

    fn borrow(&self) -> Self::Ref<'_, T> {
        RefCell::borrow(self)
    }

    fn borrow_mut(&self) -> Self::RefMut<'_, T> {
        RefCell::borrow_mut(self)
    }

    fn get_ref(&self) -> &T {
        unsafe { self.as_ptr().as_ref().unwrap() }
    }
}

impl<T> Shared<T> for Arc<parking_lot::RwLock<T>> {
    type Inner = T;
    type Ptr<U> = Arc<parking_lot::RwLock<U>>;
    type Rc<U> = Arc<U>;
    type Ref<'a, U> = parking_lot::RwLockReadGuard<'a, U> where Self: 'a, U: 'a;
    type RefMut<'a, U> = parking_lot::RwLockWriteGuard<'a, U> where Self: 'a, U: 'a;

    fn new(value: T) -> Self {
        Arc::new(parking_lot::RwLock::new(value))
    }

    fn borrow(&self) -> Self::Ref<'_, T> {
        self.read()
    }

    fn borrow_mut(&self) -> Self::RefMut<'_, T> {
        self.write()
    }

    fn get_ref(&self) -> &T {
        unsafe { self.data_ptr().as_ref().unwrap() }
    }
}

pub(crate) trait Dirty {
    fn dirty(&self) -> usize;
    fn increase_dirty(&self);
    fn decrease_dirty(&self);
}

/// Core trait for reactive components.
///
/// Objects implementing this trait can react to changes and trigger reactions
/// in dependent components.
#[allow(private_bounds)]
pub trait Reactive: Dirty {
    /// Update the signal and trigger its reaction.
    fn react(&self) -> Vec<UpdatePromise>;

    /// Clone this object as a trait object
    fn clone_box(&self) -> Box<dyn Reactive + Send + Sync>
    where
        Self: 'static;

    fn get_receivers(&self) -> &Vec<ReactiveRef>;

    fn promise(&self) -> Vec<UpdatePromise>
    where
        Self: 'static,
    {
        self.increase_dirty();
        let self_ = UpdatePromise::new(self.clone_box());
        let mut receivers: Vec<_> = self
            .get_receivers()
            .iter()
            .flat_map(|receiver| receiver.promise())
            .collect();
        receivers.insert(0, self_);
        receivers
    }
}

pub struct UpdatePromise {
    signal: ReactiveRef,
}

impl UpdatePromise {
    /// Creates a new `UpdatePromise` with the given signal.
    pub fn new(signal: ReactiveRef) -> Self {
        Self { signal }
    }

    pub fn from_signal<T, S>(signal: &SignalBase<T, S>) -> Self
    where
        T: Send + Sync + 'static,
        S: Shared<T> + Send + Sync + Clone + 'static,
        S::Ptr<Vec<ReactiveRef>>: Send + Sync,
        S::Ptr<bool>: Send + Sync,
        S::Ptr<usize>: Send + Sync,
        S::Rc<Box<GeneratorFn<T, S>>>: Send + Sync,
    {
        Self {
            signal: signal.clone_box(),
        }
    }

    /// Resolves the promise by calling the `react()` method on the signal.
    pub fn resolve(&self) {
        self.signal.decrease_dirty();
        if self.signal.dirty() == 0 {
            self.signal.react();
        }
    }
}

impl Drop for UpdatePromise {
    fn drop(&mut self) {
        self.resolve();
    }
}

/// A type alias for a reference to a `Reactive` object.
type ReactiveRef = Box<dyn Reactive + Send + Sync>;

/// A type alias for a function that generates a value of type `T`.
type GeneratorFn<T, S> = dyn Fn(&SignalBase<T, S>) -> T + Send + Sync;

/// A reactive signal that can be observed and updated.
///
/// SignalBase is the foundation for reactive programming in this library.
/// It can:
/// - Hold a value that can be read with `get()` or `borrow()`
/// - Be updated with new values via `send()`
/// - Depend on other signals and react to their changes
/// - Have other signals depend on it
pub struct SignalBase<T, S: Shared<T>> {
    inner: S,
    generator: Option<S::Rc<Box<GeneratorFn<T, S>>>>,
    receivers: S::Ptr<Vec<ReactiveRef>>,

    suspended: S::Ptr<bool>,
    dirty: S::Ptr<usize>,
}

impl<T, S: Shared<T>> SignalBase<T, S> {
    /// Creates a new independent signal with an initial value.
    pub fn new(value: T) -> Self {
        Self {
            inner: S::new(value),
            generator: None,
            receivers: S::Ptr::<Vec<ReactiveRef>>::new(Vec::new()),
            suspended: S::Ptr::<bool>::new(false),
            dirty: S::Ptr::<usize>::new(0),
        }
    }

    /// Creates a signal that depends on other signals.
    ///
    /// # Parameters
    ///
    /// - `processor`: Function that computes the signal's value from its dependencies
    /// - `effect`: Side effect function called when the signal changes, receives both
    ///   the signal reference and the newly computed value
    ///
    /// # Example
    ///
    /// ```rust
    /// // Create a signal that reacts to changes in another signal
    /// let count = SignalBase::new(0);
    /// let doubled = SignalBase::driven(
    ///     || count.get() * 2,
    ///     |_, new_value| println!("Doubled value is now: {}", new_value)
    /// );
    /// count.add_receiver(&doubled); // Register the dependency
    /// ```
    pub fn driven(
        processor: impl Fn() -> T + Send + Sync + 'static,
        effect: impl Fn(&SignalBase<T, S>, &T) -> () + Send + Sync + 'static,
    ) -> Self {
        let mut signal = Self {
            inner: S::new(processor()),
            generator: None,
            receivers: S::Ptr::<Vec<ReactiveRef>>::new(Vec::new()),
            suspended: S::Ptr::<bool>::new(false),
            dirty: S::Ptr::<usize>::new(0),
        };
        signal.generator = Some(S::Rc::init(Box::new(move |s| {
            let x = processor();
            effect(&s, &x);
            x
        })));
        signal
    }

    /// Gets the current value of the signal (cloned).
    pub fn get(&self) -> T
    where
        T: Clone,
    {
        self.inner.borrow().clone()
    }

    /// Gets the current value of the signal by reference.
    ///
    /// This method will not trigger any reactions or computations.
    pub fn borrow(&self) -> S::Ref<'_, T> {
        self.inner.borrow()
    }

    /// Gets the current value of the signal as a mutable reference.
    ///
    /// This method will not trigger any reactions or computations.
    pub fn borrow_mut(&self) -> S::RefMut<'_, T> {
        self.inner.borrow_mut()
    }

    /// Updates the signal value and notifies all dependent signals.
    ///
    /// This triggers the `react()` method on all receivers (dependent signals).
    pub fn send(&self, value: T) -> Vec<UpdatePromise> {
        self.inner.replace(value);
        if self.suspended.borrow().clone() {
            return Vec::new();
        }
        self.receivers
            .borrow()
            .iter()
            .flat_map(|receiver| receiver.promise())
            .collect()
    }

    /// Registers a dependent signal that will react when this signal changes.
    pub fn add_receiver<U: Clone>(&self, dependent: impl Deref<Target = U>)
    where
        U: Into<ReactiveRef>,
    {
        self.receivers
            .borrow_mut()
            .push(((*dependent).clone()).into());
    }

    /// Temporarily prevents this signal from notifying its dependents when changed.
    ///
    /// This is useful to avoid unnecessary reactions during batch updates.
    pub fn suspend(&self) {
        self.suspended.replace(true);
    }

    /// Re-enables notifications to dependent signals after suspension.
    pub fn resume(&self) {
        self.suspended.replace(false);
    }

    /// Creates a new independent signal with the same value and receivers.
    pub fn deep_clone(&self) -> Self
    where
        T: Clone,
        ReactiveRef: Sized,
    {
        Self {
            inner: S::new(self.inner.borrow().clone()),
            generator: self.generator.clone(),
            receivers: S::Ptr::<Vec<ReactiveRef>>::new(
                self.receivers
                    .borrow()
                    .iter()
                    .map(|receiver| receiver.clone_box())
                    .collect(),
            ),
            suspended: S::Ptr::<bool>::new(self.suspended.borrow().clone()),
            dirty: S::Ptr::<usize>::new(*self.dirty.borrow()),
        }
    }
}

impl<T, S> Reactive for SignalBase<T, S>
where
    S: Shared<T> + Send + Sync + Clone + 'static,
    S::Ptr<Vec<ReactiveRef>>: Send + Sync,
    S::Ptr<bool>: Send + Sync,
    S::Ptr<usize>: Send + Sync,
    S::Rc<Box<GeneratorFn<T, S>>>: Send + Sync,
    T: Send + Sync + 'static,
{
    fn react(&self) -> Vec<UpdatePromise> {
        let generator = self.generator.as_ref().unwrap();
        let value = (generator.as_ref())(self);
        self.send(value)
    }

    fn clone_box(&self) -> Box<dyn Reactive + Send + Sync>
    where
        Self: 'static,
    {
        Box::new(self.clone())
    }

    fn get_receivers(&self) -> &Vec<ReactiveRef> {
        self.receivers.get_ref()
    }
}

impl<T, S: Shared<T>> Clone for SignalBase<T, S> {
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
            generator: self.generator.clone(),
            receivers: self.receivers.clone(),
            suspended: self.suspended.clone(),
            dirty: self.dirty.clone(),
        }
    }
}

impl<T, S> Dirty for SignalBase<T, S>
where
    S: Shared<T> + Send + Sync + Clone + 'static,
    S::Ptr<usize>: Send + Sync,
{
    fn dirty(&self) -> usize {
        *self.dirty.borrow()
    }

    fn increase_dirty(&self) {
        self.dirty.replace(self.dirty() + 1);
    }

    fn decrease_dirty(&self) {
        self.dirty.replace(self.dirty() - 1);
    }
}

impl<T: Reactive + Send + Sync + 'static> From<T> for Box<dyn Reactive + Send + Sync> {
    fn from(value: T) -> Self {
        Box::new(value)
    }
}
