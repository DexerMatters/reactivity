use std::{
    cell::{Ref, RefCell, RefMut},
    ops::{Deref, DerefMut},
    rc::Rc,
    sync::Arc,
};

use clone_dyn::clone_dyn;

/// A trait for creating a new instance of a type with a given value.
pub trait Constructor<T> {
    /// Creates a new instance of the type with the given value.
    fn init(value: T) -> Self;
}

impl<T> Constructor<T> for Rc<T> {
    fn init(value: T) -> Self {
        Rc::new(value)
    }
}

impl<T> Constructor<T> for Arc<T> {
    fn init(value: T) -> Self {
        Arc::new(value)
    }
}

/// A trait for shared pointer types that provide interior mutability.
///
/// Implemented for `Rc<RefCell<T>>` and `Arc<parking_lot::RwLock<T>>`.
pub trait Shared<T>: Clone {
    /// The inner type of the shared pointer.
    type Inner;

    /// The pointer type used for shared ownership.
    type Ptr<U>: Shared<U>;

    /// The type of the clonable reference countable pointer.
    type Rc<U>: Constructor<U> + Deref + AsRef<U> + Clone;

    /// The type of the reference to the inner value.
    type Ref<'a, U>: Deref<Target = U>
    where
        Self: 'a,
        U: 'a;

    /// The type of the mutable reference to the inner value.
    type RefMut<'a, U>: Deref<Target = U> + DerefMut<Target = U>
    where
        Self: 'a,
        U: 'a;

    /// Creates a new instance of the shared pointer with the given value.
    fn new(value: T) -> Self;

    /// Borrows the inner value as an immutable reference.
    fn borrow(&self) -> Self::Ref<'_, T>;

    /// Borrows the inner value as a mutable reference.
    fn borrow_mut(&self) -> Self::RefMut<'_, T>;

    /// Replaces the inner value with a new value and returns the old value.
    fn replace(&self, value: T) -> Self {
        self.replace_with(|_| value)
    }

    /// Replaces the inner value with a new value generated by the given function
    fn replace_with<F>(&self, f: F) -> Self
    where
        F: FnOnce(&T) -> T,
    {
        let mut borrow = self.borrow_mut();
        let new_value = f(&*borrow);
        *borrow = new_value;
        drop(borrow);
        self.clone()
    }
}

impl<T> Shared<T> for Rc<RefCell<T>> {
    type Inner = T;
    type Ptr<U> = Rc<RefCell<U>>;
    type Rc<U> = Rc<U>;
    type Ref<'a, U> = Ref<'a, U> where Self: 'a, U: 'a;
    type RefMut<'a, U> = RefMut<'a, U> where Self: 'a, U: 'a;

    fn new(value: T) -> Self {
        Rc::new(RefCell::new(value))
    }

    fn borrow(&self) -> Self::Ref<'_, T> {
        RefCell::borrow(self)
    }

    fn borrow_mut(&self) -> Self::RefMut<'_, T> {
        RefCell::borrow_mut(self)
    }
}

impl<T> Shared<T> for Arc<parking_lot::RwLock<T>> {
    type Inner = T;
    type Ptr<U> = Arc<parking_lot::RwLock<U>>;
    type Rc<U> = Arc<U>;
    type Ref<'a, U> = parking_lot::RwLockReadGuard<'a, U> where Self: 'a, U: 'a;
    type RefMut<'a, U> = parking_lot::RwLockWriteGuard<'a, U> where Self: 'a, U: 'a;

    fn new(value: T) -> Self {
        Arc::new(parking_lot::RwLock::new(value))
    }

    fn borrow(&self) -> Self::Ref<'_, T> {
        self.read()
    }

    fn borrow_mut(&self) -> Self::RefMut<'_, T> {
        self.write()
    }
}

/// Core trait for reactive components.
///
/// Objects implementing this trait can react to changes and trigger reactions
/// in dependent components.
#[clone_dyn]
pub trait Reactive {
    /// Update the signal and trigger its reaction.
    fn react(&self);
}

/// A type alias for a reference to a `Reactive` object.
type ReactiveRef = Box<dyn Reactive + Send + Sync>;

/// A type alias for a function that generates a value of type `T`.
type GeneratorFn<T, S> = dyn Fn(&SignalBase<T, S>) -> T + Send + Sync;

/// A reactive signal that can be observed and updated.
///
/// SignalBase is the foundation for reactive programming in this library.
/// It can:
/// - Hold a value that can be read with `get()` or `borrow()`
/// - Be updated with new values via `send()`
/// - Depend on other signals and react to their changes
/// - Have other signals depend on it
pub struct SignalBase<T, S: Shared<T>> {
    inner: S,
    generator: Option<S::Rc<Box<GeneratorFn<T, S>>>>,
    receivers: S::Ptr<Vec<ReactiveRef>>,

    suspended: S::Ptr<bool>,
}

impl<T, S: Shared<T>> SignalBase<T, S> {
    /// Creates a new independent signal with an initial value.
    pub fn new(value: T) -> Self {
        let inner = S::new(value);
        let generator = None;
        let receivers = S::Ptr::<Vec<ReactiveRef>>::new(Vec::new());
        let suspended = S::Ptr::<bool>::new(false);
        Self {
            inner,
            generator,
            receivers,
            suspended,
        }
    }

    /// Creates a signal that depends on other signals.
    ///
    /// # Parameters
    ///
    /// - `processor`: Function that computes the signal's value from its dependencies
    /// - `effect`: Side effect function called when the signal changes, receives both
    ///   the signal reference and the newly computed value
    ///
    /// # Example
    ///
    /// ```rust
    /// // Create a signal that reacts to changes in another signal
    /// let count = SignalBase::new(0);
    /// let doubled = SignalBase::driven(
    ///     || count.get() * 2,
    ///     |_, new_value| println!("Doubled value is now: {}", new_value)
    /// );
    /// count.add_receiver(&doubled); // Register the dependency
    /// ```
    pub fn driven(
        processor: impl Fn() -> T + Send + Sync + 'static,
        effect: impl Fn(&SignalBase<T, S>, &T) -> () + Send + Sync + 'static,
    ) -> Self {
        let mut signal = Self {
            inner: S::new(processor()),
            generator: None,
            receivers: S::Ptr::<Vec<ReactiveRef>>::new(Vec::new()),
            suspended: S::Ptr::<bool>::new(false),
        };
        signal.generator = Some(S::Rc::init(Box::new(move |s| {
            let x = processor();
            effect(&s, &x);
            x
        })));
        signal
    }

    /// Gets the current value of the signal (cloned).
    pub fn get(&self) -> T
    where
        T: Clone,
    {
        self.inner.borrow().clone()
    }

    /// Gets the current value of the signal by reference.
    ///
    /// This method will not trigger any reactions or computations.
    pub fn borrow(&self) -> S::Ref<'_, T> {
        self.inner.borrow()
    }

    /// Gets the current value of the signal as a mutable reference.
    ///
    /// This method will not trigger any reactions or computations.
    pub fn borrow_mut(&self) -> S::RefMut<'_, T> {
        self.inner.borrow_mut()
    }

    /// Updates the signal value and notifies all dependent signals.
    ///
    /// This triggers the `react()` method on all receivers (dependent signals).
    pub fn send(&self, value: T) {
        self.inner.replace(value);
        if self.suspended.borrow().clone() {
            return;
        }
        self.receivers.borrow().iter().for_each(|receiver| {
            receiver.react();
        });
    }

    /// Registers a dependent signal that will react when this signal changes.
    pub fn add_receiver<U: Clone>(&self, dependent: impl Deref<Target = U>)
    where
        U: Into<ReactiveRef>,
    {
        self.receivers
            .borrow_mut()
            .push(((*dependent).clone()).into());
    }

    /// Temporarily prevents this signal from notifying its dependents when changed.
    ///
    /// This is useful to avoid unnecessary reactions during batch updates.
    pub fn suspend(&self) {
        self.suspended.replace(true);
    }

    /// Re-enables notifications to dependent signals after suspension.
    pub fn resume(&self) {
        self.suspended.replace(false);
    }

    /// Creates a new independent signal with the same value and receivers.
    pub fn deep_clone(&self) -> Self
    where
        T: Clone,
        Box<dyn Reactive + Send + Sync>: Clone,
    {
        let inner = S::new(self.inner.borrow().clone());
        let generator = self.generator.clone();
        let receivers = S::Ptr::<Vec<ReactiveRef>>::new(self.receivers.borrow().clone());
        let suspended = S::Ptr::<bool>::new(self.suspended.borrow().clone());
        Self {
            inner,
            generator,
            receivers,
            suspended,
        }
    }
}

impl<T, S: Shared<T>> Reactive for SignalBase<T, S> {
    fn react(&self) {
        if let Some(generator) = self.generator.as_ref() {
            let value = (generator.as_ref())(self);
            self.send(value);
        }
    }
}

impl<T, S: Shared<T>> Clone for SignalBase<T, S> {
    fn clone(&self) -> Self {
        let inner = self.inner.clone();
        let generator = self.generator.clone();
        let receivers = self.receivers.clone();
        let suspended = self.suspended.clone();
        Self {
            inner,
            generator,
            receivers,
            suspended,
        }
    }
}

impl<T: Reactive + Send + Sync + 'static> From<T> for Box<dyn Reactive + Send + Sync> {
    fn from(value: T) -> Self {
        Box::new(value)
    }
}
