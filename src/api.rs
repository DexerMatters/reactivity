use std::{
    cell::{Ref, RefCell, RefMut},
    ops::{Deref, DerefMut},
    rc::Rc,
    sync::Arc,
};

use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};

/// A trait for shared pointer types.
///
/// Implementations include `Rc<T>` and `Arc<T>`.
pub trait Shared: Clone + AsRef<Self::Inner> + Deref<Target = Self::Inner> {
    /// The inner type of the shared pointer.
    type Inner: ?Sized;
    /// The equivalent shared pointer type for a different inner type.
    type M<U: ?Sized>: Shared<Inner = U>;
    /// Creates a new instance of the shared pointer with the given value.
    fn new(value: Self::Inner) -> Self
    where
        Self::Inner: Sized;
}

impl<T: ?Sized> Shared for Rc<T> {
    type Inner = T;
    type M<U: ?Sized> = Rc<U>;

    fn new(value: T) -> Self
    where
        T: Sized,
    {
        Rc::new(value)
    }
}

impl<T: ?Sized> Shared for Arc<T> {
    type Inner = T;
    type M<U: ?Sized> = Arc<U>;

    fn new(value: T) -> Self
    where
        T: Sized,
    {
        Arc::new(value)
    }
}

/// A trait for types that provide interior mutability.
///
/// Implementations include `RefCell<T>` and `RwLock<T>`.
pub trait InternalMutable {
    /// The type of the inner value.
    type Inner: ?Sized;

    /// The type of the reference to the inner value.
    type Ref<'a>: Deref<Target = Self::Inner>
    where
        Self: 'a,
        Self::Inner: 'a;

    /// The type of the mutable reference to the inner value.
    type RefMut<'a>: Deref<Target = Self::Inner> + DerefMut<Target = Self::Inner>
    where
        Self: 'a,
        Self::Inner: 'a;

    /// Creates a new instance of the shared pointer with the given value.
    fn new(value: Self::Inner) -> Self
    where
        Self::Inner: Sized;

    /// Borrows the inner value as an immutable reference.
    fn borrow(&self) -> Self::Ref<'_>;

    /// Borrows the inner value as a mutable reference.
    fn borrow_mut(&self) -> Self::RefMut<'_>;

    /// Replaces the inner value with a new value and returns the old value.
    fn replace(&self, value: Self::Inner)
    where
        Self::Inner: Sized,
        Self: Sized,
    {
        self.replace_with(|_| value);
    }

    /// Replaces the inner value with a new value generated by the given function
    fn replace_with<F>(&self, f: F)
    where
        F: FnOnce(Self::Ref<'_>) -> Self::Inner,
        Self: Sized,
        Self::Inner: Sized,
    {
        let mut borrow = self.borrow_mut();
        let new_value = f(self.borrow());
        *borrow = new_value;
        drop(borrow);
    }
}

impl<T: ?Sized> InternalMutable for RefCell<T> {
    type Inner = T;
    type Ref<'a>
        = Ref<'a, T>
    where
        Self: 'a,
        T: 'a;
    type RefMut<'a>
        = RefMut<'a, T>
    where
        Self: 'a,
        T: 'a;

    fn new(value: T) -> Self
    where
        T: Sized,
    {
        RefCell::new(value)
    }

    fn borrow(&self) -> Self::Ref<'_> {
        RefCell::borrow(self)
    }

    fn borrow_mut(&self) -> Self::RefMut<'_> {
        RefCell::borrow_mut(self)
    }
}

impl<T: ?Sized> InternalMutable for RwLock<T> {
    type Inner = T;
    type Ref<'a>
        = RwLockReadGuard<'a, T>
    where
        Self: 'a,
        T: 'a;
    type RefMut<'a>
        = RwLockWriteGuard<'a, T>
    where
        Self: 'a,
        T: 'a;

    fn new(value: T) -> Self
    where
        T: Sized,
    {
        RwLock::new(value)
    }

    fn borrow(&self) -> Self::Ref<'_> {
        self.read()
    }

    fn borrow_mut(&self) -> Self::RefMut<'_> {
        self.write()
    }
}

/// A promise that resolves when an update to a receptive signal is completed.
///
/// When a signal is updated, it creates an `UpdatePromise` for itself and all its
/// dependents. These promises ensure that all signals are updated in the correct order.
/// When the promise is dropped, it automatically resolves by calling the `resolve` method.
pub struct UpdatePromise(pub(crate) Box<dyn Receptive>);

impl UpdatePromise {
    /// Resolves the promise by decreasing the dirty counter of the signal.
    ///
    /// If the counter reaches zero, triggers the signal's reaction.
    pub fn resolve(&self) {
        self.0.decrease();
        if self.0.count() == 0 {
            let _ = self.0.react();
        }
    }
}

impl Drop for UpdatePromise {
    fn drop(&mut self) {
        self.resolve();
    }
}

/// A trait for tracking the dirty state of reactive components.
///
/// Components with a dirty count > 0 are pending updates.
pub(crate) trait Dirty {
    /// Gets the current dirty counter value.
    fn count(&self) -> usize;
    /// Increases the dirty counter.
    fn increase(&self);
    /// Decreases the dirty counter, clamping at zero.
    fn decrease(&self);
}

impl<T> Dirty for T
where
    T: Receptive + SealedSignalTrait + 'static,
{
    fn count(&self) -> usize {
        *self.dirty().borrow()
    }

    fn increase(&self) {
        *self.dirty().borrow_mut() += 1;
    }

    fn decrease(&self) {
        *self.dirty().borrow_mut() = self.count().saturating_sub(1);
    }
}

/// Core trait for reactive components.
///
/// Objects implementing this trait can react to changes and trigger reactions
/// in dependent components.
#[allow(private_bounds)]
pub trait Receptive: Dirty {
    /// Update the signal and trigger its reaction.
    fn react(&self) -> Vec<UpdatePromise>;

    /// Create promises for this signal and all its receivers.
    ///
    /// Called when a dependency changes to schedule updates.
    fn promise(&self) -> Vec<UpdatePromise>;

    /// Clone this object as a trait object.
    fn clone_boxed(&self) -> Box<dyn Receptive>;
}

impl<T> Receptive for T
where
    T: SealedSignalTrait + 'static,
{
    fn react(&self) -> Vec<UpdatePromise> {
        let value = (self.processor().unwrap())();
        (self.effect().unwrap())(&self, &value);
        self.send(value)
    }

    fn promise(&self) -> Vec<UpdatePromise> {
        self.increase();
        let mut promises = self
            .receivers()
            .borrow()
            .iter()
            .flat_map(|receiver| receiver.promise())
            .collect::<Vec<_>>();
        promises.insert(0, UpdatePromise(self.clone_boxed()));
        promises
    }

    fn clone_boxed(&self) -> Box<dyn Receptive> {
        Box::new(Self::init(
            self.inner().clone(),
            self.effect().cloned(),
            self.processor().cloned(),
            self.receivers().clone(),
            self.dirty().clone(),
        ))
    }
}

/// Internal trait for signal implementation details.
///
/// This trait provides access to the internal fields of a signal.
pub(crate) trait SealedSignalTrait: Receptive {
    /// The type of the inner value.
    type Inner;

    /// The type of shared pointer.
    type Rc<U: ?Sized>: Shared<Inner = U>;

    /// The type that provides interior mutability.
    type Ptr<U>: InternalMutable<Inner = U>;

    /// The type of function that produces values.
    type Processor: Fn() -> Self::Inner + ?Sized;

    /// The type of function called when a new value is processed.
    type Effect: Fn(&Self, &Self::Inner) + ?Sized;

    /// The type of receivers that can depend on this signal.
    type Receiver: Receptive + ?Sized;

    /// Initialize a new signal with the given components.
    fn init(
        inner: Self::Rc<Self::Ptr<Self::Inner>>,
        effect: Option<Self::Rc<Self::Effect>>,
        processor: Option<Self::Rc<Self::Processor>>,
        receivers: Self::Rc<Self::Ptr<Vec<Box<Self::Receiver>>>>,
        dirty: Self::Rc<Self::Ptr<usize>>,
    ) -> Self;

    /// Access the inner value container.
    fn inner(&self) -> &Self::Rc<Self::Ptr<Self::Inner>>;

    /// Access the effect function if present.
    fn effect(&self) -> Option<&Self::Rc<Self::Effect>>;

    /// Access the processor function if present.
    fn processor(&self) -> Option<&Self::Rc<Self::Processor>>;

    /// Access the receivers list.
    fn receivers(&self) -> &Self::Rc<Self::Ptr<Vec<Box<Self::Receiver>>>>;

    /// Access the dirty counter.
    fn dirty(&self) -> &Self::Rc<Self::Ptr<usize>>;
}

/// Public interface for reactive signals.
///
/// Signals are reactive values that can:
/// - Hold a value that can be read with `get()` or `borrow()`
/// - Be updated with new values via `send()`
/// - Depend on other signals and react to their changes
/// - Have other signals depend on them through receivers
#[allow(private_bounds)]
pub trait SignalTrait: SealedSignalTrait {
    #[allow(private_interfaces)]
    fn new(value: Self::Inner) -> Self
    where
        Self: Sized,
        Self::Inner: Sized,
    {
        Self::init(
            Self::Rc::<Self::Ptr<Self::Inner>>::new(Self::Ptr::<Self::Inner>::new(value)),
            None,
            None,
            Self::Rc::<Self::Ptr<Vec<Box<Self::Receiver>>>>::new(Self::Ptr::<
                Vec<Box<Self::Receiver>>,
            >::new(Vec::new())),
            Self::Rc::<Self::Ptr<usize>>::new(Self::Ptr::<usize>::new(0)),
        )
    }
    #[allow(private_interfaces)]
    fn get(&self) -> Self::Inner
    where
        Self::Inner: Clone,
    {
        self.inner().borrow().clone()
    }
    #[allow(private_interfaces)]
    fn borrow(&self) -> <Self::Ptr<Self::Inner> as InternalMutable>::Ref<'_> {
        self.inner().borrow()
    }
    #[allow(private_interfaces)]
    fn borrow_mut(&self) -> <Self::Ptr<Self::Inner> as InternalMutable>::RefMut<'_> {
        self.inner().borrow_mut()
    }
    #[allow(private_interfaces)]
    /// Registers a dependent signal that will react when this signal changes.
    ///
    /// This method accepts anything that can be converted into `Box<Self::Receiver>`,
    /// so you can pass signal instances directly without manually boxing them.
    ///
    /// # Example
    /// ```
    /// let count = signal!(0);
    /// let doubled = signal!([count] count * 2);
    ///
    /// // Add doubled as a receiver of count
    /// // doubled will update automatically when count changes
    /// count.add_receiver(doubled);
    /// ```
    fn add_receiver(&self, receiver: impl Into<Box<Self::Receiver>>) {
        self.receivers().borrow_mut().push(receiver.into());
    }

    #[allow(private_interfaces)]
    fn send(&self, value: Self::Inner) -> Vec<UpdatePromise>
    where
        Self: Sized,
    {
        *self.inner().borrow_mut() = value;
        let receivers = self.receivers().borrow();

        receivers
            .iter()
            .flat_map(|receiver| receiver.promise())
            .collect::<Vec<_>>()
    }
}

impl<T: SealedSignalTrait> SignalTrait for T {}

impl<T: SignalTrait + 'static> From<T> for Box<dyn Receptive> {
    fn from(signal: T) -> Self {
        Box::new(signal)
    }
}

impl<T: SignalTrait + Send + Sync + 'static> From<T> for Box<dyn Receptive + Send + Sync> {
    fn from(signal: T) -> Self {
        Box::new(signal)
    }
}
